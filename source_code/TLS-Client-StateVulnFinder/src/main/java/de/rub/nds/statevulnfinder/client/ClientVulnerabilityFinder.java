/*
 * TLS-StateBulnFinder - A state machine analysis tool based on TLS-Attacker
 *
 * Copyright 2020-2023 Ruhr University Bochum and Paderborn University
 *
 * Licensed under Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0.txt
 */
package de.rub.nds.statevulnfinder.client;

import de.rub.nds.scanner.core.constants.ProbeType;
import de.rub.nds.scanner.core.report.ScanReport;
import de.rub.nds.statevulnfinder.client.analysis.ClientAnalyzer;
import de.rub.nds.statevulnfinder.client.extraction.ClientAlphabetFactory;
import de.rub.nds.statevulnfinder.client.extraction.TlsClientSulProvider;
import de.rub.nds.statevulnfinder.core.StateMachine;
import de.rub.nds.statevulnfinder.core.VulnerabilityFinder;
import de.rub.nds.statevulnfinder.core.config.VulnerabilityFinderConfig;
import de.rub.nds.statevulnfinder.core.extraction.LearnerReport;
import de.rub.nds.statevulnfinder.core.issue.StateMachineIssue;
import de.rub.nds.tlsattacker.core.config.delegate.GeneralDelegate;
import de.rub.nds.tlsattacker.core.config.delegate.ServerDelegate;
import de.rub.nds.tlsattacker.core.state.State;
import de.rub.nds.tlsattacker.core.workflow.ParallelExecutor;
import de.rub.nds.tlsscanner.clientscanner.config.ClientScannerConfig;
import de.rub.nds.tlsscanner.clientscanner.execution.TlsClientScanner;
import de.rub.nds.tlsscanner.clientscanner.report.ClientReport;
import de.rub.nds.tlsscanner.core.constants.TlsProbeType;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Function;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class ClientVulnerabilityFinder extends VulnerabilityFinder {

    private static final Logger LOG = LogManager.getLogger();

    public ClientVulnerabilityFinder(VulnerabilityFinderConfig finderConfig) {
        super(finderConfig);
    }

    @Override
    public void execute() {
        // Configurator.setRootLevel(Level.OFF);
        LearnerReport result =
                extractAnalyzedStateMachine(
                        ClientAlphabetFactory.getReference(), new TlsClientSulProvider());
        displayResults(result);
    }

    @Override
    public ScanReport scanHost() {
        ClientScannerConfig clientScannerConfig = new ClientScannerConfig(new GeneralDelegate());
        List<ProbeType> probes = new LinkedList<>();
        probes.add(TlsProbeType.BASIC);
        clientScannerConfig
                .getServerDelegate()
                .setPort(((ServerDelegate) finderConfig.getSulDelegate()).getPort());
        clientScannerConfig.getExecutorConfig().setProbes(probes);
        ParallelExecutor executor = new ParallelExecutor(1, 0);
        executor.setDefaultBeforeTransportInitCallback(getCallable());
        TlsClientScanner clientScanner = new TlsClientScanner(clientScannerConfig, executor);
        return clientScanner.scan();
    }

    private Function<State, Integer> getCallable() {
        return (State state) -> {
            try {
                Runtime.getRuntime().exec(finderConfig.getCommand());
                return 0;
            } catch (IOException ex) {
                LOG.error("Failed to execute run command", ex);
                return 1;
            }
        };
    }

    @Override
    public List<StateMachineIssue> findVulnerabilities(StateMachine machine) {
        ClientAnalyzer analyzer = new ClientAnalyzer(graphDetails);
        return analyzer.findVulnerabilities(machine);
    }

    @Override
    public boolean scanReportIsSuitable(ScanReport scanReport) {
        ClientReport clientReport = (ClientReport) scanReport;
        return clientReport.getClientAdvertisedCipherSuites() != null
                && !clientReport.getClientAdvertisedCipherSuites().isEmpty();
    }
}
