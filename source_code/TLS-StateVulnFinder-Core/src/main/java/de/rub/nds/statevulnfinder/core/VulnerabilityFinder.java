/*
 * TLS-StateVulnFinder - A state machine analysis tool based on TLS-Attacker
 *
 * Copyright 2020-2025 Ruhr University Bochum and Paderborn University
 *
 * Licensed under Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0.txt
 */
package de.rub.nds.statevulnfinder.core;

import de.rub.nds.scanner.core.report.ScanReport;
import de.rub.nds.statevulnfinder.core.analysis.GraphDetails;
import de.rub.nds.statevulnfinder.core.config.VulnerabilityFinderConfig;
import de.rub.nds.statevulnfinder.core.constants.VulnerabilitySearchPattern;
import de.rub.nds.statevulnfinder.core.extraction.AlphabetFactory;
import de.rub.nds.statevulnfinder.core.extraction.Extractor;
import de.rub.nds.statevulnfinder.core.extraction.IterativeExtractor;
import de.rub.nds.statevulnfinder.core.extraction.LearnerReport;
import de.rub.nds.statevulnfinder.core.extraction.TargetSulProvider;
import de.rub.nds.statevulnfinder.core.issue.StateMachineIssue;
import java.util.List;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public abstract class VulnerabilityFinder {

    private static final Logger LOG = LogManager.getLogger();

    protected final VulnerabilityFinderConfig finderConfig;

    protected final GraphDetails graphDetails = new GraphDetails();

    public VulnerabilityFinder(VulnerabilityFinderConfig finderConfig) {
        this.finderConfig = finderConfig;
    }

    public abstract void execute();

    public abstract ScanReport scanHost();

    public LearnerReport extractAnalyzedStateMachine(
            AlphabetFactory alphabetFactory, TargetSulProvider sulProvider) {
        ScanReport scanReport = null;
        if (finderConfig.getAlphabet() == null) {
            LOG.info("Using TLS-Scanner to adapt alphabet to SUL");
            scanReport = scanHost();
            if (!scanReportIsSuitable(scanReport)) {
                LOG.info(
                        "ScanReport suggests target {} is not suitable for scanning",
                        finderConfig.getImplementationName());
                return new LearnerReport(scanReport);
            }
        }
        Extractor extractor = getExtractor(scanReport, alphabetFactory, sulProvider);
        return extractor.extractAnalyzedStateMachine();
    }

    private Extractor getExtractor(
            ScanReport scanReport, AlphabetFactory alphabetFactory, TargetSulProvider sulProvider) {
        if (scanReport != null
                && finderConfig.getPattern() == VulnerabilitySearchPattern.ITERATIVE) {
            LOG.info("Extracting with increasing alphabet");
            return new IterativeExtractor(
                    finderConfig,
                    scanReport,
                    alphabetFactory.getIncreasingAlphabets(finderConfig, scanReport),
                    sulProvider);
        } else if (scanReport != null) {
            LOG.info("Extracting with generated alphabet");
            return new Extractor(
                    finderConfig,
                    scanReport,
                    alphabetFactory.createAlphabet(finderConfig.getPattern(), scanReport, true),
                    sulProvider);
        } else {
            LOG.info("Extracting with custom alphabet");
            return new Extractor(
                    finderConfig,
                    scanReport,
                    alphabetFactory.createAlphabet(finderConfig.getAlphabet()),
                    sulProvider);
        }
    }

    public abstract List<StateMachineIssue> findVulnerabilities(StateMachine machine);

    public abstract boolean scanReportIsSuitable(ScanReport scanReport);

    protected void displayResults(LearnerReport result) {
        if (!result.getAnalysisResults().isEmpty()) {
            List<StateMachineIssue> vulnerabilityList =
                    result.getAnalysisResults()
                            .get(result.getAnalysisResults().size() - 1)
                            .getConfirmedVulnerabilities();
            if (vulnerabilityList.isEmpty()) {
                LOG.info("No issues found.");
            } else {
                LOG.info("We found " + vulnerabilityList.size() + " issues.");
                LOG.info("-------------------------");
                for (StateMachineIssue vuln : vulnerabilityList) {
                    LOG.info(vuln.toString());
                }
            }
        }
    }
}
