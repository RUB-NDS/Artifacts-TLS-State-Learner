/*
 * TLS-StateVulnFinder - A state machine analysis tool based on TLS-Attacker
 *
 * Copyright 2020-2025 Ruhr University Bochum and Paderborn University
 *
 * Licensed under Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0.txt
 */
package de.rub.nds.statevulnfinder.core.config;

import com.beust.jcommander.Parameter;
import de.rub.nds.statevulnfinder.core.VulnerabilityFinder;
import de.rub.nds.statevulnfinder.core.constants.EquivalenceTestAlgorithmName;
import de.rub.nds.statevulnfinder.core.constants.LearningAlgorithmName;
import de.rub.nds.statevulnfinder.core.constants.TransportType;
import de.rub.nds.statevulnfinder.core.constants.VulnerabilitySearchPattern;
import de.rub.nds.tlsattacker.core.config.TLSDelegateConfig;
import de.rub.nds.tlsattacker.core.config.delegate.Delegate;
import de.rub.nds.tlsattacker.core.config.delegate.GeneralDelegate;
import de.rub.nds.tlsattacker.transport.ConnectionEndType;
import java.util.List;

public abstract class VulnerabilityFinderConfig extends TLSDelegateConfig {

    public static boolean SIMPLE_CIPHER_SUITE_EXPORT_MODE = false;

    @Parameter(
            names = "-searchPattern",
            required = true,
            description = "For which VulnerabilityPattern to search for")
    private VulnerabilitySearchPattern pattern = VulnerabilitySearchPattern.ITERATIVE;

    @Parameter(
            names = "-alphabet",
            required = false,
            description =
                    "A list of comma separated strings from which a custom alphabet is constructed. "
                            + "If supplied, scanning is bypassed and the search pattern is no longer used for generating the alphabet. ")
    private List<String> alphabet = null;

    @Parameter(names = "-output", description = "In which folder should results be saved in")
    private String output = "output/";

    @Parameter(
            names = "-learningAlgorithm",
            description = "Which algorithm should be used for learning")
    private LearningAlgorithmName learningAlgorithm = LearningAlgorithmName.TTT;

    @Parameter(
            names = "-equivalenceAlgorithm",
            description = "Which algorithm should be used for equivalance testing")
    private EquivalenceTestAlgorithmName equivalenceAlgorithm =
            EquivalenceTestAlgorithmName.RANDOM_WORDS_STATE;

    @Parameter(names = "-depth", description = "Maximal depth ( W/WP Method)")
    private int maxDepth = 15;

    @Parameter(names = "-minLength", description = "Min length (random words)")
    private int minLength = 7;

    @Parameter(names = "-maxLength", description = "Max length (random words)")
    private int maxLength = 15;

    @Parameter(names = "-queries", description = "Number of queries (random words)")
    private int numberOfQueries = 50000;

    @Parameter(
            names = "-guidedQueries",
            description = "Number of additional random word queries for guided tests")
    private int numberOfGuidedQueries = 10000;

    @Parameter(names = "-hyp", description = "Exports intermediate hypothesis")
    private boolean exportHypotheses = false;

    @Parameter(names = "-noCacheTrapping", description = "Disable trapping in cache")
    private boolean noCacheTrapping = false;

    @Parameter(
            names = "-noSpecificReceive",
            description = "Disable specific receive actions that levarage cached prefixes")
    private boolean noSpecificReceive = false;

    @Parameter(names = "-disableCache", description = "Bypass Cache in all cases")
    private boolean disableCache = false;

    @Parameter(names = "-export", description = "Export results")
    private boolean exportResults = true;

    @Parameter(names = "-majorityVote", description = "Number of votes in a majority vote")
    private int majorityVote = 7;

    @Parameter(
            names = "-alphabetLimit",
            description = "Maximum number of alphabets to iterate over")
    private int alphabetLimit = -1;

    @Parameter(
            names = "-maxConnections",
            description = "Maximum number of real connections for the learner (-1 = infinite)")
    private int maxConnections = -1;

    @Parameter(
            names = "-implementationName",
            description = "Name of the tested implementation. Used during model extraction")
    private String implementationName = "unspecified";

    @Parameter(
            names = "-transport",
            required = false,
            description = "Transport layer protocol used",
            converter = TransportTypeConverter.class)
    private TransportType transport = TransportType.TCP;

    @Parameter(
            names = "-minTimeout",
            required = false,
            description = "Time the learner spends waiting for a response")
    private Integer minTimeout = 100;

    @Parameter(
            names = "-maxTimeout",
            required = false,
            description = "The maximum timeout used for incremented timeouts upon cache exceptions")
    private Integer maxTimeout = 1000;

    @Parameter(
            names = "-analysisTimeout",
            required = false,
            description = "The maximum duration of an analysis step")
    private Long analysisTimeout = 60000L;

    @Parameter(
            names = "-rstWait",
            required = false,
            description = "Time the learner waits after executing each query")
    private Long resetWait = 0L;

    @Parameter(
            names = {"-command", "-cmd"},
            required = false,
            description = "Command for starting the (D)TLS process")
    private String command = null;

    @Parameter(
            names = "-runWait",
            required = false,
            description = "Time waited after running each TLS command")
    private Long runWait = 0L;

    @Parameter(
            names = "-slowCache",
            description =
                    "If set do not speed up algorithm by answering uninteresting Bleichenbacher and "
                            + "Padding Oracle words in the cache")
    private boolean slowCache = false;

    @Parameter(names = "-rawResults", description = "Export only raw results (stats and XML)")
    private boolean writeOnlyCrucialResults = false;

    public boolean isWriteOnlyCrucialResults() {
        return writeOnlyCrucialResults;
    }

    public void setWriteOnlyCrucialResults(boolean writeOnlyCrucialResults) {
        this.writeOnlyCrucialResults = writeOnlyCrucialResults;
    }

    public VulnerabilityFinderConfig(GeneralDelegate delegate) {
        super(delegate);
    }

    public abstract Delegate getSulDelegate();

    public VulnerabilitySearchPattern getPattern() {
        return pattern;
    }

    public void setPattern(VulnerabilitySearchPattern pattern) {
        this.pattern = pattern;
    }

    public String getOutput() {
        return output;
    }

    public void setOutput(String output) {
        this.output = output;
    }

    public LearningAlgorithmName getLearningAlgorithm() {
        return learningAlgorithm;
    }

    public EquivalenceTestAlgorithmName getEquivalenceAlgorithm() {
        return equivalenceAlgorithm;
    }

    public int getMaxDepth() {
        return maxDepth;
    }

    public int getMinLength() {
        return minLength;
    }

    public int getMaxLength() {
        return maxLength;
    }

    public int getNumberOfQueries() {
        return numberOfQueries;
    }

    public boolean getExportHypotheses() {
        return exportHypotheses;
    }

    public List<String> getAlphabet() {
        return alphabet;
    }

    public int getMajorityVote() {
        return majorityVote;
    }

    public void setAlphabet(List<String> alphabet) {
        this.alphabet = alphabet;
    }

    public String getImplementationName() {
        return implementationName;
    }

    public TransportType getTransport() {
        return transport;
    }

    public void setTransport(TransportType transport) {
        this.transport = transport;
    }

    public Integer getMinTimeout() {
        return minTimeout;
    }

    public void setMinTimeout(Integer minTimeout) {
        this.minTimeout = minTimeout;
    }

    public String getCommand() {
        return command;
    }

    public void setCommand(String command) {
        this.command = command;
    }

    public Long getResetWait() {
        return resetWait;
    }

    public void setResetWait(Long resetWait) {
        this.resetWait = resetWait;
    }

    public Long getRunWait() {
        return runWait;
    }

    public void setRunWait(Long runWait) {
        this.runWait = runWait;
    }

    public abstract VulnerabilityFinder createVulnerabilityFinder();

    public abstract ConnectionEndType getFinderConnectionEnd();

    public boolean isSlowCache() {
        return slowCache;
    }

    public int getMaxConnections() {
        return maxConnections;
    }

    public void setMaxConnections(int maxConnections) {
        this.maxConnections = maxConnections;
    }

    public Integer getMaxTimeout() {
        return maxTimeout;
    }

    public void setMaxTimeout(Integer maxTimeout) {
        this.maxTimeout = maxTimeout;
    }

    public void setExportHypotheses(boolean exportHypotheses) {
        this.exportHypotheses = exportHypotheses;
    }

    public void setLearningAlgorithm(LearningAlgorithmName learningAlgorithm) {
        this.learningAlgorithm = learningAlgorithm;
    }

    public void setEquivalenceAlgorithm(EquivalenceTestAlgorithmName equivalenceAlgorithm) {
        this.equivalenceAlgorithm = equivalenceAlgorithm;
    }

    public void setMaxDepth(int maxDepth) {
        this.maxDepth = maxDepth;
    }

    public void setMinLength(int minLength) {
        this.minLength = minLength;
    }

    public void setMaxLength(int maxLength) {
        this.maxLength = maxLength;
    }

    public void setNumberOfQueries(int numberOfQueries) {
        this.numberOfQueries = numberOfQueries;
    }

    public boolean isExportHypotheses() {
        return exportHypotheses;
    }

    public void setMajorityVote(int majorityVote) {
        this.majorityVote = majorityVote;
    }

    public void setImplementationName(String implementationName) {
        this.implementationName = implementationName;
    }

    public void setSlowCache(boolean slowCache) {
        this.slowCache = slowCache;
    }

    public boolean isExportResults() {
        return exportResults;
    }

    public void setExportResults(boolean exportResults) {
        this.exportResults = exportResults;
    }

    public int getNumberOfGuidedQueries() {
        return numberOfGuidedQueries;
    }

    public void setNumberOfGuidedQueries(int numberOfGuidedQueries) {
        this.numberOfGuidedQueries = numberOfGuidedQueries;
    }

    public Long getAnalysisTimeout() {
        return analysisTimeout;
    }

    public void setAnalysisTimeout(Long analysisTimeout) {
        this.analysisTimeout = analysisTimeout;
    }

    public boolean isNoCacheTrapping() {
        return noCacheTrapping;
    }

    public void setNoCacheTrapping(boolean noCacheTrapping) {
        this.noCacheTrapping = noCacheTrapping;
    }

    public boolean isNoSpecificReceive() {
        return noSpecificReceive;
    }

    public void setNoSpecificReceive(boolean noSpecificReceive) {
        this.noSpecificReceive = noSpecificReceive;
    }

    public boolean isDisableCache() {
        return disableCache;
    }

    public void setDisableCache(boolean disableCache) {
        this.disableCache = disableCache;
    }

    public int getAlphabetLimit() {
        return alphabetLimit;
    }

    public void setAlphabetLimit(int alphabetLimit) {
        this.alphabetLimit = alphabetLimit;
    }
}
