/*
 * TLS-StateVulnFinder - A state machine analysis tool based on TLS-Attacker
 *
 * Copyright 2020-2025 Ruhr University Bochum and Paderborn University
 *
 * Licensed under Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0.txt
 */
package de.rub.nds.statevulnfinder.server;

import de.rub.nds.scanner.core.constants.ListResult;
import de.rub.nds.scanner.core.report.ScanReport;
import de.rub.nds.statevulnfinder.core.StateMachine;
import de.rub.nds.statevulnfinder.core.VulnerabilityFinder;
import de.rub.nds.statevulnfinder.core.config.VulnerabilityFinderConfig;
import de.rub.nds.statevulnfinder.core.extraction.LearnerReport;
import de.rub.nds.statevulnfinder.core.issue.StateMachineIssue;
import de.rub.nds.statevulnfinder.core.sul.ProcessHandler;
import de.rub.nds.statevulnfinder.server.analysis.ServerAnalyzer;
import de.rub.nds.statevulnfinder.server.config.ServerSulDelegate;
import de.rub.nds.statevulnfinder.server.extraction.ServerAlphabetFactory;
import de.rub.nds.statevulnfinder.server.extraction.TlsServerSulProvider;
import de.rub.nds.tlsattacker.core.config.delegate.GeneralDelegate;
import de.rub.nds.tlsattacker.core.constants.ProtocolVersion;
import de.rub.nds.tlsscanner.core.constants.TlsAnalyzedProperty;
import de.rub.nds.tlsscanner.core.constants.TlsProbeType;
import de.rub.nds.tlsscanner.serverscanner.config.ServerScannerConfig;
import de.rub.nds.tlsscanner.serverscanner.execution.TlsServerScanner;
import de.rub.nds.tlsscanner.serverscanner.report.ServerReport;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class ServerVulnerabilityFinder extends VulnerabilityFinder {

    private static final Logger LOG = LogManager.getLogger();

    public ServerVulnerabilityFinder(VulnerabilityFinderConfig finderConfig) {
        super(finderConfig);
    }

    @Override
    public void execute() {
        LearnerReport result =
                extractAnalyzedStateMachine(
                        new ServerAlphabetFactory(), new TlsServerSulProvider());
        displayResults(result);
    }

    @Override
    public ScanReport scanHost() {
        ServerScannerConfig scannerConfig = new ServerScannerConfig(new GeneralDelegate());
        scannerConfig
                .getClientDelegate()
                .setHost(((ServerSulDelegate) finderConfig.getSulDelegate()).getHost());
        scannerConfig.setTimeout(1000);
        ProcessHandler processHandler = null;
        if (finderConfig.getCommand() != null) {
            processHandler = new ProcessHandler(finderConfig);
            processHandler.launchProcess();
        }
        scannerConfig
                .getExecutorConfig()
                .setProbes(
                        TlsProbeType.COMMON_BUGS,
                        TlsProbeType.CIPHER_SUITE,
                        TlsProbeType.CERTIFICATE,
                        TlsProbeType.COMPRESSIONS,
                        TlsProbeType.NAMED_GROUPS,
                        TlsProbeType.PROTOCOL_VERSION,
                        TlsProbeType.EC_POINT_FORMAT,
                        TlsProbeType.RESUMPTION,
                        TlsProbeType.EXTENSIONS,
                        TlsProbeType.RECORD_FRAGMENTATION,
                        TlsProbeType.HELLO_RETRY,
                        TlsProbeType.HTTP_HEADER,
                        TlsProbeType.TLS_LATENCY,
                        TlsProbeType.CONNECTION_CLOSING_DELTA);
        scannerConfig.getExecutorConfig().setOverallThreads(1);
        scannerConfig.getExecutorConfig().setParallelProbes(1);
        scannerConfig.setConfigSearchCooldown(true);

        TlsServerScanner scanner = new TlsServerScanner(scannerConfig);
        ServerReport scanReport = scanner.scan();

        if (finderConfig.getCommand() != null) {
            processHandler.terminateProcess();
        }

        adjustTimeout(scanReport);

        return scanReport;
    }

    private void adjustTimeout(ServerReport scanReport) {
        List<Long> obtainedMeasurements = new LinkedList<>();
        if (scanReport.getResult(TlsAnalyzedProperty.TLS_LATENCY_HELLO) instanceof ListResult) {
            obtainedMeasurements.addAll(
                    ((ListResult) scanReport.getResult(TlsAnalyzedProperty.TLS_LATENCY_HELLO))
                            .getList());
        }
        if (scanReport.getResult(TlsAnalyzedProperty.TLS_LATENCY_KEY_EXCHANGE)
                instanceof ListResult) {
            obtainedMeasurements.addAll(
                    ((ListResult)
                                    scanReport.getResult(
                                            TlsAnalyzedProperty.TLS_LATENCY_KEY_EXCHANGE))
                            .getList());
        }
        while (obtainedMeasurements.contains(null)) {
            obtainedMeasurements.remove(null);
        }
        if (!obtainedMeasurements.isEmpty()) {
            int timeout = (int) (Collections.max(obtainedMeasurements) * 1.5 / 1000000);
            if (timeout >= finderConfig.getMinTimeout()
                    && timeout <= finderConfig.getMaxTimeout()) {
                LOG.info(
                        "[TIMEOUT-INIT] Set initial timeout of {} for {} based on scan results",
                        timeout,
                        finderConfig.getImplementationName());
                finderConfig.setMinTimeout(timeout);
            } else if (timeout > finderConfig.getMaxTimeout()) {
                LOG.warn(
                        "[TIMEOUT-INIT] Computed timeout of {} for {} is above maximum - will start with max timeout {}",
                        timeout,
                        finderConfig.getImplementationName(),
                        finderConfig.getMaxTimeout());
                finderConfig.setMinTimeout(finderConfig.getMaxTimeout());
            }
        } else {
            LOG.warn(
                    "[TIMEOUT-INIT] no latency measurements obtained for {}, using middle of timeout limits ({})",
                    finderConfig.getImplementationName(),
                    finderConfig.getMinTimeout()
                            + ((finderConfig.getMaxTimeout() - finderConfig.getMinTimeout()) / 2));
        }
    }

    @Override
    public List<StateMachineIssue> findVulnerabilities(StateMachine machine) {
        LOG.info(
                "Starting vulnerability analysis for {} - Hypothesis has {} states",
                finderConfig.getImplementationName(),
                machine.getMealyMachine().getStates().size());
        long timestamp = System.currentTimeMillis();
        ServerAnalyzer analyzer = new ServerAnalyzer(graphDetails);
        List<StateMachineIssue> vulnerabilities = analyzer.findVulnerabilities(machine);
        LOG.info(
                "Finished vulnerability analysis for {} - Took {} seconds",
                finderConfig.getImplementationName(),
                (timestamp - System.currentTimeMillis()) / (long) (1000));
        return vulnerabilities;
    }

    @Override
    public boolean scanReportIsSuitable(ScanReport scanReport) {
        ServerReport serverReport = (ServerReport) scanReport;
        return serverReport.getServerIsAlive() == true
                && serverReport.getSpeaksProtocol() == true
                && serverReport.getListResult(TlsAnalyzedProperty.SUPPORTED_PROTOCOL_VERSIONS)
                        != null
                && (serverReport
                                .getListResult(TlsAnalyzedProperty.SUPPORTED_PROTOCOL_VERSIONS)
                                .getList()
                                .contains(ProtocolVersion.TLS12)
                        || serverReport
                                .getListResult(TlsAnalyzedProperty.SUPPORTED_PROTOCOL_VERSIONS)
                                .getList()
                                .contains(ProtocolVersion.TLS13))
                && serverReport.getSetResult(TlsAnalyzedProperty.SUPPORTED_CIPHERSUITES).getSet()
                        != null
                && !serverReport
                        .getSetResult(TlsAnalyzedProperty.SUPPORTED_CIPHERSUITES)
                        .getSet()
                        .isEmpty();
    }
}
